{"name":"The Virtual Repository","tagline":"Pluggable API for Standards-based Data Import & Publication","body":"There is a lot of data out there that may be fed to your application, and not all of it can reach it from that pretty \"upload\" button you show to your users. \r\n\r\nThere are also lots of places out there which your app may feed back, now that it has changed, transformed, or enriched whatever data you could lay your hands on.\r\n\r\nPity then that developing good **import** and **publish** functionalities_ should take so much effort. Yes, there are a handful of protocols/formats in your domain that put some order in what you may expect to find, or be expected to produce. And you're even prepared to map a few of these \"standards\" to and fro' the data model that rules within your app (after all, who else can do this but you?).\r\n\r\nBut you still need to contend with a variety of sources and sinks, each of which may require you to support one more standard or, worse, a custom data model (e.g. some XML or RDF language). You also need to find some way to paper over differences, and present your application and your users with a uniform view of what data can come in and what places it can travel to.\r\n\r\nThe **Virtual Repository** helps you build this view. It is a client library, just a mere Jar. So, target one or two key standards for import/publish, and prepare to map them to and from your own model. Then ask the Virtual Repository to discover all the data \"in the hood\" which is available in the standards you support. Let your users pick one, and ask the Virtual Repository to give you its content in an API you want to work with. Do your mapping and be done. And when it comes to publish your data, ask the Virtual Repository who \"in the hood\" may accept one of the standards you support. Let your users pick one of the possible sinks, transform the data, and tell the Virtual Repository to send it to destination for you. Quite a step beyond your \"upload\" button!\r\n\r\nSo who's in \"the hood\"? The Virtual Repository finds out when you start the app. It looks around the machine for other Jars that advertise some repository service capable of giving and/or taking data in some standards. Inside these Jars there live **plugins** that cooperate with the Virtual Repository to satisfy your requests. Each plugin knows how to discover, fetch, and publish data to and fro' some remote service , either a specific service (e.g. that pesky RDBMS in your institution) or any service of a specific class (e.g. any SDMX Registry). And each plugin knows how to adapt data for its service, i.e. convert its expectations to and fro' one of the standard you support. That's how the Virtual Repository shields your app from knowing how to talk to the world outside, and from the full range of standards you'd otherwise need to map.\r\n\r\nWant to know more? **Check out our code and wiki on GitHub**.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}